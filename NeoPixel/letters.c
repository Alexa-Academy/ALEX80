#include <string.h>
#include "letters.h"
#include "neopixel.h"
#include "time.h"

#define COLOR 0xFF0000 // Colore rosso (RGB in formato 0xRRGGBB)
#define MATRIX_WIDTH 8 
#define MATRIX_HEIGHT 8

extern unsigned int ref[];

unsigned char font[37][8] = {
  // Lettere maiuscole (A-Z)
  {0x1E, 0x12, 0x12, 0x12, 0x3F, 0x21, 0x21, 0x21},  // A
  {0x3E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x11, 0x3E},  // B
  {0x0F, 0x11, 0x20, 0x20, 0x20, 0x20, 0x11, 0x0F},  // C
  {0x3C, 0x12, 0x11, 0x11, 0x11, 0x11, 0x12, 0x3C},  // D
  {0x3F, 0x20, 0x20, 0x3E, 0x20, 0x20, 0x20, 0x3F},  // E
  {0x3F, 0x20, 0x20, 0x3E, 0x20, 0x20, 0x20, 0x20},  // F
  {0x0F, 0x11, 0x20, 0x20, 0x23, 0x21, 0x11, 0x0F},  // G
  {0x21, 0x21, 0x21, 0x3F, 0x21, 0x21, 0x21, 0x21},  // H
  {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E},  // I
  {0x0F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x24, 0x18},  // J
  {0x21, 0x22, 0x24, 0x38, 0x24, 0x22, 0x21, 0x21},  // K
  {0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3F},  // L
  {0x21, 0x33, 0x2D, 0x2D, 0x21, 0x21, 0x21, 0x21},  // M
  {0x21, 0x31, 0x29, 0x25, 0x23, 0x21, 0x21, 0x21},  // N
  {0x1E, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1E},  // O
  {0x3E, 0x11, 0x11, 0x11, 0x3E, 0x20, 0x20, 0x20},  // P
  {0x1E, 0x21, 0x21, 0x21, 0x21, 0x25, 0x22, 0x1D},  // Q
  {0x3E, 0x11, 0x11, 0x11, 0x3E, 0x22, 0x21, 0x21},  // R
  {0x1E, 0x21, 0x10, 0x0C, 0x02, 0x01, 0x21, 0x1E},  // S
  {0x3F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C},  // T
  {0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1E},  // U
  {0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x12, 0x0C},  // V
  {0x21, 0x21, 0x21, 0x2D, 0x2D, 0x2D, 0x33, 0x21},  // W
  {0x21, 0x21, 0x12, 0x0C, 0x0C, 0x12, 0x21, 0x21},  // X
  {0x21, 0x21, 0x21, 0x21, 0x12, 0x0C, 0x0C, 0x0C},  // Y
  {0x3F, 0x01, 0x02, 0x0C, 0x10, 0x20, 0x20, 0x3F},  // Z

  // Numeri (0-9)
  {0x1E, 0x21, 0x23, 0x25, 0x29, 0x31, 0x21, 0x1E},  // 0
  {0x0C, 0x1C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E},  // 1
  {0x1E, 0x21, 0x01, 0x02, 0x0C, 0x10, 0x20, 0x3F},  // 2
  {0x1E, 0x21, 0x01, 0x0E, 0x01, 0x01, 0x21, 0x1E},  // 3
  {0x06, 0x0A, 0x12, 0x22, 0x3F, 0x02, 0x02, 0x02},  // 4
  {0x3F, 0x20, 0x3E, 0x01, 0x01, 0x01, 0x21, 0x1E},  // 5
  {0x1E, 0x21, 0x20, 0x3E, 0x21, 0x21, 0x21, 0x1E},  // 6
  {0x3F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10},  // 7
  {0x1E, 0x21, 0x21, 0x1E, 0x21, 0x21, 0x21, 0x1E},  // 8
  {0x1E, 0x21, 0x21, 0x21, 0x1F, 0x01, 0x21, 0x1E},  // 9

  // Spazio
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}  // Space
};

// Restituisce l'indice del carattere nell'array font
int getFontIndex(char c) {
  if (c >= 'A' && c <= 'Z') {
    return c - 'A';
  } else if (c >= '0' && c <= '9') {
    return 26 + (c - '0');
  } else {
    return 36; // Spazio
  }
}

// Visualizza una stringa con scorrimento
void scrollText(const char *text, int speed) {
  int textLength = strlen(text);
  for (int offset = 0; offset < textLength * (MATRIX_WIDTH + 1); offset++) {
    neopixel_clear();
    for (int i = 0; i < textLength; i++) {
      int charOffset = (i * (MATRIX_WIDTH + 1)) - offset;
      if (charOffset >= -MATRIX_WIDTH && charOffset < MATRIX_WIDTH) {
        drawChar(charOffset, text[i]);
      }
    }
    neopixel_show();
    delay(speed/10);
  }
}

/*
void displayLetter(char c) {
  int index = getFontIndex(c);

  neopixel_clear();
  for (int row = 0; row < 8; row++) {
    unsigned char line = font[index][row];
    for (int col = 0; col < 8; col++) {
      int pixelIndex = row * 8 + col; // Calcola l'indice del LED
      if (line & (0x80 >> col)) {    // Controlla se il bit è impostato
        neopixel_setPixelColor_rgb(ref[pixelIndex], COLOR); // Imposta il colore
      } else {
        neopixel_setPixelColor_rgb(ref[pixelIndex], 0); // Spegne il LED
      }
    }
  }
  neopixel_show();
}
*/

void drawChar(int x, char c) {
  int index = getFontIndex(c); // Ottieni l'indice del carattere nel font
  for (int row = 0; row < 8; row++) { // Itera sulle 8 righe
    unsigned char line = font[index][row];     // Riga del carattere
    for (int col = 0; col < 6; col++) { // Itera sulle 6 colonne
      int pixelX = x + col; // Posizione orizzontale nella matrice
      int pixelY = row;     // Posizione verticale nella matrice

      // Ignora i pixel fuori dai limiti della matrice
      if (pixelX < 0 || pixelX >= MATRIX_WIDTH || pixelY < 0 || pixelY >= MATRIX_HEIGHT) {
        continue;
      }

      // Calcola l'indice lineare del pixel nella matrice
      int pixelIndex = ref[pixelY * MATRIX_WIDTH + pixelX];

      // Accendi il LED solo se il bit corrispondente è impostato
      if (line & (0x20 >> col)) { // 6 colonne = usa 0x20 come maschera
        neopixel_setPixelColor_rgb(pixelIndex, COLOR);
      }
    }
  }
}
